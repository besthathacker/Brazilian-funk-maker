<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Funk Studio Pro - Brazilian Funk Vibe</title>
<style>
  /* Background: colorful funky Brazilian style, Base64 embedded */
  body {
    margin: 0;
    padding: 1em;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #eee;
    user-select: none;
    background: 
      linear-gradient(45deg, rgba(255,64,129,0.6), rgba(255,175,64,0.6)),
      url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwMCIgaGVpZ2h0PSI2MDAiIHZpZXdCb3g9IjAgMCAxMDAwIDYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMDAiIGhlaWdodD0iNjAwIiBmaWxsPSIjMjU1ZjQ4Ii8+CjxjaXJjbGUgY3g9IjMwMCIgY3k9IjIwMCIgcj0iNjAiIGZpbGw9IiNmZjQ3NzMiIG9wYWNpdHk9IjAuNzUiLz4KPGNpcmNsZSBjeD0iNzAwIiBjeT0iNDAwIiByPSI3MCIgZmlsbD0iI2ZmNzYzNiIgb3BhY2l0eT0iMC43NSIvPgo8cmVjdCB4PSI0MDAiIHk9IjMwMCIgd2lkdGg9IjIwMCIgaGVpZ2h0PSIyMDAiIGZpbGw9IiNmZjgwYzYiIG9wYWNpdHk9IjAuNiIgcng9IjQwIi8+CjxsaW5lIHgxPSI1MCIgeTE9IjAiIHgyPSIyMDAiIHkyPSIyMDAiIHN0cm9rZT0iI2ZmZjQ4MSIgc3Ryb2tlLXdpZHRoPSI1Ii8+CjxsaW5lIHgxPSI5MDAiIHkxPSI2MDAiIHgyPSI3NTUiIHkyPSIyMDAiIHN0cm9rZT0iI2ZmZjQ4MSIgc3Ryb2tlLXdpZHRoPSI1Ii8+Cjwvc3ZnPg==") no-repeat center center fixed;
    background-size: cover;
    position: relative;
  }

  /* Overlay to keep text readable */
  body::before {
    content: "";
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(18, 18, 18, 0.75);
    pointer-events: none;
    z-index: 0;
  }

  h1 {
    color: #ff79a8;
    position: relative;
    z-index: 1;
  }

  .container {
    max-width: 900px;
    margin: 0 auto;
    position: relative;
    z-index: 1;
  }

  button, input[type=range], select {
    background: #ff4081;
    border: none;
    color: white;
    padding: 0.5em 1em;
    margin: 0.3em;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.3s ease;
  }
  button:hover, select:hover {
    background: #ff79a8;
  }
  input[type=checkbox] {
    width: 18px;
    height: 18px;
    cursor: pointer;
  }
  label {
    user-select: none;
  }
  .grid {
    display: grid;
    grid-template-columns: 80px repeat(16, 30px);
    gap: 5px;
    justify-content: center;
    margin: 1em 0;
  }
  .grid label {
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 8px;
    font-weight: bold;
  }
  .step {
    width: 28px;
    height: 28px;
    background: #222;
    border-radius: 4px;
    transition: background 0.15s;
  }
  .step.active {
    background: #ff4081;
  }
  canvas {
    width: 100%;
    height: 150px;
    background: #222;
    border-radius: 10px;
    margin: 1em 0;
  }
  .controls, .sliders, .vocal-fx, .synth, .recording, .preset-section {
    margin: 1em 0;
  }
  .track-control {
    display: flex;
    justify-content: center;
    gap: 15px;
    align-items: center;
    margin: 0.5em 0;
  }
  .track-control label {
    margin-right: 0.3em;
  }
  .vocal-fx button, .preset-section button {
    min-width: 70px;
  }
  .drag-area {
    border: 2px dashed #ff79a8;
    border-radius: 10px;
    padding: 1em;
    margin-top: 1em;
    color: #ff79a8;
    font-style: italic;
  }
  .drag-area p {
    margin: 0;
  }
  .preset-section input {
    width: 200px;
    padding: 0.3em;
    border-radius: 6px;
    border: none;
    margin-right: 0.5em;
  }
</style>
</head>
<body>
<div class="container">
  <h1>üéõÔ∏è Funk Studio Pro - Brazilian Funk Vibe</h1>

  <div class="controls">
    <button id="playStopBtn">‚ñ∂Ô∏è Play</button>
    <button id="swingToggleBtn">Swing: Off</button>
  </div>

  <div class="sliders">
    <label>BPM: <span id="bpmDisplay">140</span></label><br />
    <input type="range" id="bpmSlider" min="60" max="200" value="140" />
    <br />
    <label>Master Volume: <span id="volDisplay">0.8</span></label><br />
    <input type="range" id="volSlider" min="0" max="1" step="0.01" value="0.8" />
  </div>

  <div class="grid" id="sequencerGrid"></div>

  <h2>üé§ Vocal FX Sequencer</h2>
  <div class="grid" id="vocalGrid"></div>

  <div class="vocal-fx">
    <button data-vocal="vai">Vai!</button>
    <button data-vocal="senta">Senta!</button>
    <button data-vocal="bate">Bate!</button>
  </div>

  <div class="drag-area" id="dragArea">
    <p>Drag & drop MP3/WAV samples here to add layers</p>
  </div>

  <h2>üéπ Melody Synth Automation</h2>
  <div class="grid" id="synthGrid"></div>
  <div class="synth-controls">
    <label>Waveform:
      <select id="waveformSelect">
        <option value="sine">Sine</option>
        <option value="square">Square</option>
        <option value="triangle">Triangle</option>
        <option value="sawtooth">Sawtooth</option>
      </select>
    </label>
  </div>

  <h2>üéõÔ∏è Track Mixer</h2>
  <div class="track-control">
    <label>Kick Volume</label>
    <input type="range" id="kickVol" min="0" max="1" step="0.01" value="0.8" />
    <label>Kick Pan</label>
    <input type="range" id="kickPan" min="-1" max="1" step="0.01" value="0" />
  </div>
  <div class="track-control">
    <label>Snare Volume</label>
    <input type="range" id="snareVol" min="0" max="1" step="0.01" value="0.8" />
    <label>Snare Pan</label>
    <input type="range" id="snarePan" min="-1" max="1" step="0.01" value="0" />
  </div>
  <div class="track-control">
    <label>HiHat Volume</label>
    <input type="range" id="hihatVol" min="0" max="1" step="0.01" value="0.5" />
    <label>HiHat Pan</label>
    <input type="range" id="hihatPan" min="-1" max="1" step="0.01" value="0" />
  </div>
  <div class="track-control">
    <label>Sample Volume</label>
    <input type="range" id="sampleVol" min="0" max="1" step="0.01" value="0.8" />
    <label>Sample Pan</label>
    <input type="range" id="samplePan" min="-1" max="1" step="0.01" value="0" />
  </div>

  <canvas id="visualizer" width="800" height="150"></canvas>

  <div class="recording">
    <button id="startRecBtn">üéôÔ∏è Start Recording</button>
    <button id="stopRecBtn" disabled>üõë Stop & Export</button>
    <div id="downloadLinks"></div>
  </div>

  <div class="preset-section">
    <input type="text" id="presetName" placeholder="Preset Name" />
    <button id="savePresetBtn">üíæ Save Preset</button>
    <button id="loadPresetBtn">üìÇ Load Preset</button>
  </div>

  <!-- Vocal FX Audio -->
  <audio id="vai" src="https://cdn.freesound.org/previews/692/692314_12054908-lq.mp3"></audio>
  <audio id="senta" src="https://cdn.freesound.org/previews/692/692315_12054908-lq.mp3"></audio>
  <audio id="bate" src="https://cdn.freesound.org/previews/692/692316_12054908-lq.mp3"></audio>

<script>
  // Audio Context & Nodes
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioContext();

  // Master Gain
  const masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.8;
  masterGain.connect(audioCtx.destination);

  // Analyser for visualizer
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  masterGain.connect(analyser);
  const dataArray = new Uint8Array(analyser.frequencyBinCount);

  // Variables
  let isPlaying = false;
  let currentStep = 0;
  const totalSteps = 16;
  let swingEnabled = false;

  // Scheduler
  let timerID;
  let nextNoteTime = 0;
  let bpm = 140;
  const scheduleAheadTime = 0.1; // seconds
  const lookahead = 25; // ms

  // Drum Track Settings
  const drumTracks = ['kick', 'snare', 'hihat'];
  const drumBuffers = {};
  const drumGainNodes = {};
  const drumPanNodes = {};

  // Sample Track
  let sampleBuffer = null;
  const sampleGainNode = audioCtx.createGain();
  const samplePanNode = audioCtx.createStereoPanner();
  sampleGainNode.connect(samplePanNode);
  samplePanNode.connect(masterGain);
  sampleGainNode.gain.value = 0.8;

  // Synth Track
  let synthOsc = null;
  let synthGainNode = audioCtx.createGain();
  synthGainNode.gain.value = 0;
  synthGainNode.connect(masterGain);

  // Vocal FX Audio elements
  const vocalFX = {
    'vai': document.getElementById('vai'),
    'senta': document.getElementById('senta'),
    'bate': document.getElementById('bate')
  };

  // Vocal FX Sequencer data
  const vocalGridData = Array(totalSteps).fill(null).map(() => ({ vai: false, senta: false, bate: false }));

  // Synth Automation data: freq per step (Hz)
  const synthGridData = new Array(totalSteps).fill(440);

  // Sequencer data (drums)
  const sequencerData = {
    kick: new Array(totalSteps).fill(false),
    snare: new Array(totalSteps).fill(false),
    hihat: new Array(totalSteps).fill(false)
  };

  // Initialize drum gain and pan nodes
  drumTracks.forEach(track => {
    drumGainNodes[track] = audioCtx.createGain();
    drumPanNodes[track] = audioCtx.createStereoPanner();
    drumGainNodes[track].connect(drumPanNodes[track]);
    drumPanNodes[track].connect(masterGain);
    drumGainNodes[track].gain.value = 0.8;
    drumPanNodes[track].pan.value = 0;
  });

  // Load drum samples (kick/snare/hihat)
  async function loadDrumSamples() {
    const urls = {
      kick: 'https://cdn.freesound.org/previews/20/20712_512123-lq.mp3',
      snare: 'https://cdn.freesound.org/previews/82/82921_1022651-lq.mp3',
      hihat: 'https://cdn.freesound.org/previews/33/33858_15520-lq.mp3'
    };
    for (const [name, url] of Object.entries(urls)) {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      drumBuffers[name] = await audioCtx.decodeAudioData(arrayBuffer);
    }
  }
  loadDrumSamples();

  // Create grids
  const sequencerGrid = document.getElementById('sequencerGrid');
  const vocalGrid = document.getElementById('vocalGrid');
  const synthGrid = document.getElementById('synthGrid');
  const playStopBtn = document.getElementById('playStopBtn');
  const swingToggleBtn = document.getElementById('swingToggleBtn');
  const bpmSlider = document.getElementById('bpmSlider');
  const bpmDisplay = document.getElementById('bpmDisplay');
  const volSlider = document.getElementById('volSlider');
  const volDisplay = document.getElementById('volDisplay');
  const downloadLinks = document.getElementById('downloadLinks');
  const startRecBtn = document.getElementById('startRecBtn');
  const stopRecBtn = document.getElementById('stopRecBtn');
  const presetNameInput = document.getElementById('presetName');
  const savePresetBtn = document.getElementById('savePresetBtn');
  const loadPresetBtn = document.getElementById('loadPresetBtn');
  const waveformSelect = document.getElementById('waveformSelect');
  const dragArea = document.getElementById('dragArea');

  // Setup sequencer grid for drums
  function setupSequencerGrid() {
    sequencerGrid.innerHTML = '';
    // header row
    sequencerGrid.appendChild(document.createElement('div'));
    for (let i = 0; i < totalSteps; i++) {
      const stepLabel = document.createElement('div');
      stepLabel.textContent = (i + 1);
      sequencerGrid.appendChild(stepLabel);
    }
    drumTracks.forEach(track => {
      const label = document.createElement('label');
      label.textContent = track.charAt(0).toUpperCase() + track.slice(1);
      sequencerGrid.appendChild(label);
      for (let i = 0; i < totalSteps; i++) {
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'step';
        checkbox.dataset.track = track;
        checkbox.dataset.step = i;
        checkbox.checked = sequencerData[track][i];
        checkbox.addEventListener('change', () => {
          sequencerData[track][i] = checkbox.checked;
        });
        sequencerGrid.appendChild(checkbox);
      }
    });
  }

  // Setup vocal FX grid
  function setupVocalGrid() {
    vocalGrid.innerHTML = '';
    // header
    vocalGrid.appendChild(document.createElement('div'));
    for (let i = 0; i < totalSteps; i++) {
      const stepLabel = document.createElement('div');
      stepLabel.textContent = (i + 1);
      vocalGrid.appendChild(stepLabel);
    }
    ['vai','senta','bate'].forEach(vocal => {
      const label = document.createElement('label');
      label.textContent = vocal.charAt(0).toUpperCase() + vocal.slice(1);
      vocalGrid.appendChild(label);
      for(let i=0;i<totalSteps;i++) {
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'vocalStep';
        cb.dataset.vocal = vocal;
        cb.dataset.step = i;
        cb.checked = vocalGridData[i][vocal];
        cb.addEventListener('change', () => {
          vocalGridData[cb.dataset.step][vocal] = cb.checked;
        });
        vocalGrid.appendChild(cb);
      }
    });
  }

  // Setup synth automation grid
  function setupSynthGrid() {
    synthGrid.innerHTML = '';
    synthGrid.style.gridTemplateColumns = `80px repeat(${totalSteps}, 30px)`;
    // header
    synthGrid.appendChild(document.createElement('div'));
    for (let i = 0; i < totalSteps; i++) {
      const stepLabel = document.createElement('div');
      stepLabel.textContent = (i + 1);
      synthGrid.appendChild(stepLabel);
    }
    const label = document.createElement('label');
    label.textContent = 'Freq (Hz)';
    synthGrid.appendChild(label);
    for (let i = 0; i < totalSteps; i++) {
      const input = document.createElement('input');
      input.type = 'number';
      input.min = 100;
      input.max = 1000;
      input.value = synthGridData[i];
      input.style.width = '50px';
      input.dataset.step = i;
      input.addEventListener('input', () => {
        synthGridData[input.dataset.step] = Number(input.value);
      });
      synthGrid.appendChild(input);
    }
  }

  // Play drum sample at scheduled time
  function playSample(buffer, time, track) {
    const source = audioCtx.createBufferSource();
    source.buffer = buffer;
    const gainNode = drumGainNodes[track];
    const panNode = drumPanNodes[track];
    source.connect(gainNode);
    gainNode.connect(panNode);
    panNode.connect(masterGain);
    source.start(time);
  }

  // Play sample track buffer
  function playSampleBuffer(time) {
    if(!sampleBuffer) return;
    const source = audioCtx.createBufferSource();
    source.buffer = sampleBuffer;
    source.connect(sampleGainNode);
    source.start(time);
  }

  // Play vocal FX
  function playVocalFX(name) {
    const audioElem = vocalFX[name];
    if(!audioElem) return;
    audioElem.pause();
    audioElem.currentTime = 0;
    audioElem.play();
  }

  // Play synth note (simple oscillator)
  function playSynthNote(freq, time) {
    if(synthOsc) {
      synthOsc.stop(time);
      synthOsc.disconnect();
    }
    synthOsc = audioCtx.createOscillator();
    synthOsc.type = waveformSelect.value;
    synthOsc.frequency.setValueAtTime(freq, time);
    synthOsc.connect(synthGainNode);
    synthGainNode.gain.setValueAtTime(0.3, time);
    synthOsc.start(time);
    synthOsc.stop(time + 0.3);
  }

  // Scheduler function
  function scheduler() {
    while(nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
      scheduleStep(currentStep, nextNoteTime);
      advanceNote();
    }
    timerID = setTimeout(scheduler, lookahead);
  }

  // Schedule single step
  function scheduleStep(step, time) {
    drumTracks.forEach(track => {
      if(sequencerData[track][step]) {
        playSample(drumBuffers[track], time, track);
      }
    });

    // Sample track plays every 4 steps (1 bar)
    if(sampleBuffer && (step % 4 === 0)) {
      playSampleBuffer(time);
    }

    // Vocal FX plays if toggled on step
    const vocals = vocalGridData[step];
    for(const vocal in vocals) {
      if(vocals[vocal]) playVocalFX(vocal);
    }

    // Play synth note
    playSynthNote(synthGridData[step], time);

    highlightStep(step);
  }

  // Highlight current step in grids
  function highlightStep(step) {
    document.querySelectorAll('#sequencerGrid input.step, #vocalGrid input.vocalStep, #synthGrid input').forEach(el => {
      if(el.dataset.step == step) el.classList.add('active');
      else el.classList.remove('active');
    });
  }

  // Clear highlights
  function clearHighlights() {
    document.querySelectorAll('.active').forEach(el => el.classList.remove('active'));
  }

  // Advance note time with optional swing
  function advanceNote() {
    const secondsPerBeat = 60.0 / bpm;
    if(swingEnabled && (currentStep % 2 === 1)) {
      nextNoteTime += secondsPerBeat / 4 * 1.5;
    } else {
      nextNoteTime += secondsPerBeat / 4;
    }
    currentStep++;
    if(currentStep >= totalSteps) currentStep = 0;
  }

  // Play / Stop button handler
  function play() {
    if(!isPlaying) {
      if(audioCtx.state === 'suspended') audioCtx.resume();
      currentStep = 0;
      nextNoteTime = audioCtx.currentTime + 0.05;
      scheduler();
      playStopBtn.textContent = '‚è∏Ô∏è Stop';
      isPlaying = true;
    } else {
      clearTimeout(timerID);
      playStopBtn.textContent = '‚ñ∂Ô∏è Play';
      clearHighlights();
      isPlaying = false;
    }
  }

  // Toggle swing mode
  function toggleSwing() {
    swingEnabled = !swingEnabled;
    swingToggleBtn.textContent = swingEnabled ? 'Swing: On' : 'Swing: Off';
  }

  // Volume and BPM handlers
  bpmSlider.addEventListener('input', () => {
    bpm = Number(bpmSlider.value);
    bpmDisplay.textContent = bpm;
  });

  volSlider.addEventListener('input', () => {
    const val = Number(volSlider.value);
    masterGain.gain.value = val;
    volDisplay.textContent = val.toFixed(2);
  });

  // Drag and drop sample loader
  dragArea.addEventListener('dragover', e => e.preventDefault());
  dragArea.addEventListener('drop', e => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if(!file) return;
    if(!file.type.startsWith('audio')) {
      alert('Please drop a valid audio file (MP3 or WAV).');
      return;
    }
    const reader = new FileReader();
    reader.onload = (evt) => {
      audioCtx.decodeAudioData(evt.target.result).then(buffer => {
        sampleBuffer = buffer;
        alert('Sample loaded successfully!');
      });
    };
    reader.readAsArrayBuffer(file);
  });

  // Vocal FX buttons play
  document.querySelectorAll('.vocal-fx button').forEach(btn => {
    btn.addEventListener('click', () => {
      playVocalFX(btn.dataset.vocal);
    });
  });

  // Mixer controls setup
  ['kick', 'snare', 'hihat', 'sample'].forEach(track => {
    document.getElementById(track + 'Vol').addEventListener('input', e => {
      const val = Number(e.target.value);
      if(track === 'sample') sampleGainNode.gain.value = val;
      else drumGainNodes[track].gain.value = val;
    });
    document.getElementById(track + 'Pan').addEventListener('input', e => {
      const val = Number(e.target.value);
      if(track === 'sample') samplePanNode.pan.value = val;
      else drumPanNodes[track].pan.value = val;
    });
  });

  // Preset save/load
  function savePreset() {
    const preset = {
      bpm,
      swingEnabled,
      sequencerData,
      vocalGridData,
      synthGridData,
      waveform: waveformSelect.value,
      mixer: {
        kickVol: document.getElementById('kickVol').value,
        snareVol: document.getElementById('snareVol').value,
        hihatVol: document.getElementById('hihatVol').value,
        sampleVol: document.getElementById('sampleVol').value,
        kickPan: document.getElementById('kickPan').value,
        snarePan: document.getElementById('snarePan').value,
        hihatPan: document.getElementById('hihatPan').value,
        samplePan: document.getElementById('samplePan').value
      }
    };
    localStorage.setItem('funkStudioPreset_' + presetNameInput.value, JSON.stringify(preset));
    alert('Preset saved as "' + presetNameInput.value + '"');
  }

  function loadPreset() {
    const name = presetNameInput.value;
    if(!name) {
      alert('Enter a preset name to load');
      return;
    }
    const json = localStorage.getItem('funkStudioPreset_' + name);
    if(!json) {
      alert('Preset "' + name + '" not found');
      return;
    }
    const preset = JSON.parse(json);
    bpm = preset.bpm;
    bpmSlider.value = bpm;
    bpmDisplay.textContent = bpm;
    swingEnabled = preset.swingEnabled;
    swingToggleBtn.textContent = swingEnabled ? 'Swing: On' : 'Swing: Off';

    Object.assign(sequencerData, preset.sequencerData);
    Object.assign(vocalGridData, preset.vocalGridData);
    for(let i=0; i<totalSteps; i++) synthGridData[i] = preset.synthGridData[i];
    waveformSelect.value = preset.waveform;

    ['kick','snare','hihat','sample'].forEach(track => {
      document.getElementById(track + 'Vol').value = preset.mixer[track + 'Vol'];
      document.getElementById(track + 'Pan').value = preset.mixer[track + 'Pan'];
    });

    setupSequencerGrid();
    setupVocalGrid();
    setupSynthGrid();
    alert('Preset "' + name + '" loaded');
  }

  savePresetBtn.addEventListener('click', savePreset);
  loadPresetBtn.addEventListener('click', loadPreset);

  // Visualizer drawing
  const canvas = document.getElementById('visualizer');
  const ctx = canvas.getContext('2d');
  function drawVisualizer() {
    requestAnimationFrame(drawVisualizer);
    analyser.getByteFrequencyData(dataArray);
    ctx.fillStyle = '#121212';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const barWidth = canvas.width / dataArray.length;
    for(let i=0; i<dataArray.length; i++) {
      const barHeight = dataArray[i];
      ctx.fillStyle = `rgb(255, 64, 129)`;
      ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth, barHeight);
    }
  }
  drawVisualizer();

  // Recording with MediaRecorder
  let recorder;
  let recordedChunks = [];

  startRecBtn.addEventListener('click', () => {
    if(recorder && recorder.state === 'recording') {
      alert('Already recording!');
      return;
    }
    if(audioCtx.state === 'suspended') audioCtx.resume();

    const dest = audioCtx.createMediaStreamDestination();
    masterGain.connect(dest);
    recorder = new MediaRecorder(dest.stream);
    recordedChunks = [];

    recorder.ondataavailable = e => {
      if(e.data.size > 0) recordedChunks.push(e.data);
    };

    recorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: 'audio/wav' });
      const url = URL.createObjectURL(blob);

      const wavLink = document.createElement('a');
      wavLink.href = url;
      wavLink.download = 'funk_beat.wav';
      wavLink.textContent = 'Download WAV';
      wavLink.style.marginRight = '10px';

      encodeMp3(blob).then(mp3Url => {
        const mp3Link = document.createElement('a');
        mp3Link.href = mp3Url;
        mp3Link.download = 'funk_beat.mp3';
        mp3Link.textContent = 'Download MP3';

        downloadLinks.innerHTML = '';
        downloadLinks.appendChild(wavLink);
        downloadLinks.appendChild(mp3Link);
      }).catch(e => {
        alert('MP3 encoding failed: ' + e.message);
        downloadLinks.innerHTML = '';
        downloadLinks.appendChild(wavLink);
      });

      startRecBtn.disabled = false;
      stopRecBtn.disabled = true;
    };

    recorder.start();
    startRecBtn.disabled = true;
    stopRecBtn.disabled = false;
  });

  stopRecBtn.addEventListener('click', () => {
    if(recorder && recorder.state === 'recording') {
      recorder.stop();
    }
  });

  // MP3 encoding with lamejs from CDN
  // See below for function
</script>
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
<script>
  async function encodeMp3(blob) {
    const arrayBuffer = await blob.arrayBuffer();

    // Decode WAV header (simplified)
    const wav = lamejs.WavHeader.readHeader(new DataView(arrayBuffer));
    const samples = new Int16Array(arrayBuffer, wav.dataOffset, wav.dataLen / 2);

    const mp3Encoder = new lamejs.Mp3Encoder(wav.channels, wav.sampleRate, 128);
    const maxSamples = 1152;
    let mp3Data = [];

    for(let i = 0; i < samples.length; i += maxSamples) {
      const sampleChunk = samples.subarray(i, i + maxSamples);
      const mp3buf = mp3Encoder.encodeBuffer(sampleChunk);
      if(mp3buf.length > 0) mp3Data.push(mp3buf);
    }
    const mp3buf = mp3Encoder.flush();
    if(mp3buf.length > 0) mp3Data.push(mp3buf);

    const mp3Blob = new Blob(mp3Data, { type: 'audio/mp3' });
    return URL.createObjectURL(mp3Blob);
  }

  // Initialize grids
  setupSequencerGrid();
  setupVocalGrid();
  setupSynthGrid();

  // Event listeners
  playStopBtn.addEventListener('click', play);
  swingToggleBtn.addEventListener('click', toggleSwing);
</script>
</div>
</body>
</html>
