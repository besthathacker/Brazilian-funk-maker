<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Funk Studio + Meme Maker</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    background: #111;
    color: #eee;
  }
  header {
    background: #222;
    padding: 1rem;
    text-align: center;
    font-size: 1.5rem;
    font-weight: bold;
  }
  nav {
    display: flex;
    background: #333;
  }
  nav button {
    flex: 1;
    padding: 1rem;
    background: #333;
    color: #eee;
    border: none;
    cursor: pointer;
    font-size: 1rem;
  }
  nav button.active {
    background: #0c9;
    color: #111;
    font-weight: bold;
  }
  section {
    display: none;
    padding: 1rem;
    max-width: 960px;
    margin: auto;
  }
  section.active {
    display: block;
  }
  /* Funk Studio styles */
  .funk-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit,minmax(100px,1fr));
    gap: 0.5rem;
    margin-bottom: 1rem;
  }
  .funk-pad {
    background: #0c9;
    color: #111;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 60px;
  }
  .funk-pad:hover {
    background: #09a;
  }
  .fx-buttons button.active {
    background: #09a;
    color: #fff;
  }
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  canvas {
    width: 100%;
    background: #111;
    border: 1px solid #333;
    border-radius: 4px;
  }
  /* Meme Maker */
  #memeCanvas {
    max-width: 100%;
    border: 2px solid #0c9;
    border-radius: 6px;
  }
  input, select, textarea {
    background: #222;
    border: 1px solid #444;
    color: #eee;
    padding: 0.4rem;
    border-radius: 4px;
    margin-bottom: 0.5rem;
    width: 100%;
    box-sizing: border-box;
  }
  label {
    margin-top: 0.5rem;
    display: block;
  }
  .brainrot-presets button {
    margin: 0 0.2rem 0.2rem 0;
    padding: 0.3rem 0.6rem;
    background: #222;
    color: #0c9;
    border: 1px solid #0c9;
    border-radius: 4px;
    cursor: pointer;
  }
  .brainrot-presets button:hover {
    background: #0c9;
    color: #111;
  }
  footer {
    text-align: center;
    padding: 1rem;
    color: #555;
    font-size: 0.8rem;
  }
</style>
</head>
<body>

<header>Ultimate Funk Studio + Meme Maker</header>
<nav>
  <button id="tabFunk" class="active">Funk Studio</button>
  <button id="tabMeme">Image Meme Maker</button>
  <button id="tabVideoMeme">Video Meme Maker</button>
  <button id="tabBrainRot">Brain Rot Maker</button>
</nav>

<!-- FUNK STUDIO -->
<section id="funkStudio" class="active">
  <h2>Funk Studio</h2>
  <div class="funk-grid" id="drumPads">
    <!-- pads will be generated by JS -->
  </div>

  <input type="file" id="sampleUpload" accept="audio/mp3, audio/mpeg, audio/wav, audio/ogg" multiple />
  <div id="sampleList"></div>

  <div class="fx-buttons">
    <button id="fxReverb">Reverb</button>
    <button id="fxDelay">Delay</button>
    <button id="fxDistortion">Distortion</button>
  </div>

  <h3>Synthesizer</h3>
  <label>Frequency: <input type="range" id="synthFreq" min="100" max="1000" value="440" /></label>
  <label>Volume: <input type="range" id="synthVol" min="0" max="1" step="0.01" value="0.5" /></label>
  <button id="playSynthBtn">Play Synth</button>

  <h3>Mixer</h3>
  <label>Master Volume: <input type="range" id="masterVol" min="0" max="1" step="0.01" value="0.7" /></label>

  <h3>Playback Controls</h3>
  <button id="playBtn">Play Beat</button>
  <button id="pauseBtn" disabled>Pause</button>
  <label><input type="checkbox" id="swingToggle" /> Swing</label>

  <h3>Waveform Visualizer</h3>
  <canvas id="waveform" height="100"></canvas>

  <h3>Recording & Export</h3>
  <button id="startRecording">Start Recording</button>
  <button id="stopRecording" disabled>Stop Recording</button>
  <button id="exportMP3" disabled>Export MP3</button>
  <button id="exportWAV" disabled>Export WAV</button>
</section>

<!-- IMAGE MEME MAKER -->
<section id="memeMaker">
  <h2>Image Meme Maker</h2>
  <input type="file" id="imageUpload" accept="image/*" />
  <canvas id="memeCanvas"></canvas>
  <label>Top Text: <input type="text" id="topText" placeholder="TOP TEXT" /></label>
  <label>Bottom Text: <input type="text" id="bottomText" placeholder="BOTTOM TEXT" /></label>
  <label>Font Size: <input type="number" id="fontSize" value="40" min="10" max="100" /></label>
  <label>Font Color: <input type="color" id="fontColor" value="#ffffff" /></label>
  <button id="downloadMemeBtn">Download Meme</button>
</section>

<!-- VIDEO MEME MAKER -->
<section id="videoMemeMaker">
  <h2>Video Meme Maker</h2>
  <input type="file" id="videoUpload" accept="video/mp4, video/webm, video/ogg, video/mpeg, video/quicktime" />
  <video id="videoElem" controls style="display:none; max-width:100%;"></video>
  <canvas id="videoCanvas" style="display:none;"></canvas>
  <label>Top Text: <input type="text" id="videoTopText" placeholder="TOP TEXT" /></label>
  <label>Bottom Text: <input type="text" id="videoBottomText" placeholder="BOTTOM TEXT" /></label>
  <button id="playVideoBtn" disabled>Play</button>
  <button id="pauseVideoBtn" disabled>Pause</button>
  <button id="downloadVideoMemeBtn" disabled>Download Snapshot</button>
  <button id="exportVideoBtn" disabled>Export 5s Video Meme</button>
</section>

<!-- BRAIN ROT MAKER -->
<section id="brainRotMaker">
  <h2>Brain Rot Maker</h2>
  <input type="file" id="brainRotUpload" accept="image/*,video/mp4, video/webm, video/ogg, video/mpeg, video/quicktime" />
  <video id="brainRotVideo" controls style="display:none; max-width:100%;"></video>
  <canvas id="brainRotCanvas" style="display:none;"></canvas>
  <div class="brainrot-presets" style="margin: 0.5rem 0;">
    <button data-preset="none">None</button>
    <button data-preset="glitch">Glitch</button>
    <button data-preset="pixelate">Pixelate</button>
    <button data-preset="noise">Noise</button>
    <button data-preset="colorShift">Color Shift</button>
    <button data-preset="invert">Invert</button>
  </div>
  <button id="playBrainRotBtn" disabled>Play Video</button>
  <button id="pauseBrainRotBtn" disabled>Pause Video</button>
  <button id="downloadBrainRotBtn" disabled>Download Image Snapshot</button>
</section>

<footer>Â© 2025 Funk & Meme Studio</footer>

<script>
  // Navigation tabs
  const tabs = {
    funk: document.getElementById('tabFunk'),
    meme: document.getElementById('tabMeme'),
    videoMeme: document.getElementById('tabVideoMeme'),
    brainRot: document.getElementById('tabBrainRot'),
  };
  const sections = {
    funk: document.getElementById('funkStudio'),
    meme: document.getElementById('memeMaker'),
    videoMeme: document.getElementById('videoMemeMaker'),
    brainRot: document.getElementById('brainRotMaker'),
  };
  function setActiveTab(tabKey) {
    Object.keys(tabs).forEach(key => {
      tabs[key].classList.toggle('active', key === tabKey);
      sections[key].classList.toggle('active', key === tabKey);
    });
  }
  Object.entries(tabs).forEach(([key, btn]) => {
    btn.onclick = () => setActiveTab(key);
  });

  /* ==== FUNK STUDIO ==== */
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.7;
  masterGain.connect(audioCtx.destination);

  const drumSampleURLs = {
    kick: 'https://cdn.jsdelivr.net/gh/jbrown/DRUMS/kick.wav',
    'hihat-closed': 'https://cdn.jsdelivr.net/gh/jbrown/DRUMS/hihat_closed.wav',
    snare: 'https://cdn.jsdelivr.net/gh/jbrown/DRUMS/snare.wav',
    'hihat-open': 'https://cdn.jsdelivr.net/gh/jbrown/DRUMS/hihat_open.wav'
  };
  const samples = {};
  const drumPadsDiv = document.getElementById('drumPads');

  // Create drum pads dynamically
  Object.keys(drumSampleURLs).forEach(name => {
    const btn = document.createElement('div');
    btn.className = 'funk-pad';
    btn.textContent = name.toUpperCase();
    btn.dataset.sound = name;
    drumPadsDiv.appendChild(btn);
  });

  const drumPads = Array.from(document.querySelectorAll('.funk-pad'));

  async function loadSample(name, url) {
    const res = await fetch(url);
    const arrayBuffer = await res.arrayBuffer();
    samples[name] = await audioCtx.decodeAudioData(arrayBuffer);
  }

  function playSample(name) {
    if (!samples[name]) return;
    const source = audioCtx.createBufferSource();
    source.buffer = samples[name];
    source.connect(masterGain);
    source.start();
  }

  (async () => {
    for (const [name, url] of Object.entries(drumSampleURLs)) {
      try {
        await loadSample(name, url);
      } catch (e) {
        console.warn('Failed to load sample', name);
      }
    }
  })();

  drumPads.forEach(pad => {
    pad.onclick = () => {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      playSample(pad.dataset.sound);
    };
  });

  // Sample upload
  const sampleUpload = document.getElementById('sampleUpload');
  const sampleList = document.getElementById('sampleList');

  sampleUpload.addEventListener('change', e => {
    const files = e.target.files;
    for (const file of files) {
      const reader = new FileReader();
      reader.onload = async () => {
        const arrayBuffer = reader.result;
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        const name = file.name;
        samples[name] = audioBuffer;
        const item = document.createElement('div');
        item.textContent = `Loaded sample: ${name}`;
        sampleList.appendChild(item);
      };
      reader.readAsArrayBuffer(file);
    }
  });

  // FX toggle buttons
  let reverbOn = false, delayOn = false, distortionOn = false;
  const fxButtons = {
    reverb: document.getElementById('fxReverb'),
    delay: document.getElementById('fxDelay'),
    distortion: document.getElementById('fxDistortion'),
  };

  fxButtons.reverb.onclick = () => {
    reverbOn = !reverbOn;
    fxButtons.reverb.classList.toggle('active', reverbOn);
  };
  fxButtons.delay.onclick = () => {
    delayOn = !delayOn;
    fxButtons.delay.classList.toggle('active', delayOn);
  };
  fxButtons.distortion.onclick = () => {
    distortionOn = !distortionOn;
    fxButtons.distortion.classList.toggle('active', distortionOn);
  };

  // Synth oscillator
  const synthFreq = document.getElementById('synthFreq');
  const synthVol = document.getElementById('synthVol');
  const playSynthBtn = document.getElementById('playSynthBtn');

  playSynthBtn.onclick = () => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.frequency.value = synthFreq.value;
    gainNode.gain.value = synthVol.value;
    osc.connect(gainNode);
    gainNode.connect(masterGain);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.5);
  };

  // Mixer volume
  const masterVol = document.getElementById('masterVol');
  masterVol.oninput = () => {
    masterGain.gain.value = masterVol.value;
  };

  // Playback controls
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const swingToggle = document.getElementById('swingToggle');

  let playing = false;
  let playInterval = null;
  let beatIndex = 0;
  const beatPattern = ['kick', 'hihat-closed', 'snare', 'hihat-closed', 'kick', 'hihat-closed', 'snare', 'hihat-open'];

  function playBeat() {
    if (beatIndex >= beatPattern.length) beatIndex = 0;
    playSample(beatPattern[beatIndex]);
    beatIndex++;
  }

  playBtn.onclick = () => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    if (!playing) {
      playing = true;
      let intervalTime = swingToggle.checked ? 300 : 400;
      playBeat();
      playInterval = setInterval(playBeat, intervalTime);
      playBtn.disabled = true;
      pauseBtn.disabled = false;
    }
  };
  pauseBtn.onclick = () => {
    playing = false;
    clearInterval(playInterval);
    playBtn.disabled = false;
    pauseBtn.disabled = true;
  };

  // Waveform visualizer
  const waveformCanvas = document.getElementById('waveform');
  const waveformCtx = waveformCanvas.getContext('2d');
  const analyser = audioCtx.createAnalyser();
  masterGain.connect(analyser);
  analyser.fftSize = 256;
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);

  function drawWaveform() {
    requestAnimationFrame(drawWaveform);
    analyser.getByteTimeDomainData(dataArray);
    waveformCtx.fillStyle = '#111';
    waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
    waveformCtx.lineWidth = 2;
    waveformCtx.strokeStyle = '#0c9';
    waveformCtx.beginPath();
    const sliceWidth = waveformCanvas.width * 1.0 / bufferLength;
    let x = 0;
    for (let i = 0; i < bufferLength; i++) {
      const v = dataArray[i] / 128.0;
      const y = v * waveformCanvas.height / 2;
      if (i === 0) {
        waveformCtx.moveTo(x, y);
      } else {
        waveformCtx.lineTo(x, y);
      }
      x += sliceWidth;
    }
    waveformCtx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
    waveformCtx.stroke();
  }
  drawWaveform();

  // Recording & Export
  let mediaRecorder;
  let recordedChunks = [];

  const startRecordingBtn = document.getElementById('startRecording');
  const stopRecordingBtn = document.getElementById('stopRecording');
  const exportMP3Btn = document.getElementById('exportMP3');
  const exportWAVBtn = document.getElementById('exportWAV');

  startRecordingBtn.onclick = () => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const dest = audioCtx.createMediaStreamDestination();
    masterGain.connect(dest);
    mediaRecorder = new MediaRecorder(dest.stream);
    recordedChunks = [];
    mediaRecorder.ondataavailable = e => {
      if (e.data.size > 0) recordedChunks.push(e.data);
    };
    mediaRecorder.onstop = () => {
      exportMP3Btn.disabled = false;
      exportWAVBtn.disabled = false;
    };
    mediaRecorder.start();
    startRecordingBtn.disabled = true;
    stopRecordingBtn.disabled = false;
    exportMP3Btn.disabled = true;
    exportWAVBtn.disabled = true;
  };
  stopRecordingBtn.onclick = () => {
    mediaRecorder.stop();
    startRecordingBtn.disabled = false;
    stopRecordingBtn.disabled = true;
  };
  exportMP3Btn.onclick = () => {
    const blob = new Blob(recordedChunks, { type: 'audio/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'funk_recording.webm';
    a.click();
    URL.revokeObjectURL(url);
  };
  exportWAVBtn.onclick = () => {
    // WAV export: tricky in-browser without libs; fallback to webm for now
    alert('WAV export is not supported in this demo. Please use MP3 (webm) export.');
  };

  /* ==== MEME MAKER ==== */
  const imageUpload = document.getElementById('imageUpload');
  const memeCanvas = document.getElementById('memeCanvas');
  const memeCtx = memeCanvas.getContext('2d');
  const topTextInput = document.getElementById('topText');
  const bottomTextInput = document.getElementById('bottomText');
  const fontSizeInput = document.getElementById('fontSize');
  const fontColorInput = document.getElementById('fontColor');
  const downloadMemeBtn = document.getElementById('downloadMemeBtn');

  let memeImage = new Image();

  function drawMeme() {
    memeCanvas.width = memeImage.width;
    memeCanvas.height = memeImage.height;
    memeCtx.clearRect(0, 0, memeCanvas.width, memeCanvas.height);
    memeCtx.drawImage(memeImage, 0, 0);
    const fontSize = parseInt(fontSizeInput.value);
    memeCtx.font = `${fontSize}px Impact, Arial Black, sans-serif`;
    memeCtx.fillStyle = fontColorInput.value;
    memeCtx.strokeStyle = 'black';
    memeCtx.lineWidth = fontSize / 15;
    memeCtx.textAlign = 'center';
    memeCtx.textBaseline = 'top';

    // Top text
    const topText = topTextInput.value.toUpperCase();
    memeCtx.fillText(topText, memeCanvas.width / 2, 10);
    memeCtx.strokeText(topText, memeCanvas.width / 2, 10);

    // Bottom text
    const bottomText = bottomTextInput.value.toUpperCase();
    memeCtx.textBaseline = 'bottom';
    memeCtx.fillText(bottomText, memeCanvas.width / 2, memeCanvas.height - 10);
    memeCtx.strokeText(bottomText, memeCanvas.width / 2, memeCanvas.height - 10);
  }

  imageUpload.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      memeImage.onload = () => {
        drawMeme();
      };
      memeImage.src = reader.result;
    };
    reader.readAsDataURL(file);
  };

  [topTextInput, bottomTextInput, fontSizeInput, fontColorInput].forEach(el => {
    el.oninput = drawMeme;
  });

  downloadMemeBtn.onclick = () => {
    const link = document.createElement('a');
    link.download = 'meme.png';
    link.href = memeCanvas.toDataURL('image/png');
    link.click();
  };

  /* ==== VIDEO MEME MAKER ==== */
  const videoUpload = document.getElementById('videoUpload');
  const videoElem = document.getElementById('videoElem');
  const videoCanvas = document.getElementById('videoCanvas');
  const videoCtx = videoCanvas.getContext('2d');
  const videoTopText = document.getElementById('videoTopText');
  const videoBottomText = document.getElementById('videoBottomText');
  const playVideoBtn = document.getElementById('playVideoBtn');
  const pauseVideoBtn = document.getElementById('pauseVideoBtn');
  const downloadVideoMemeBtn = document.getElementById('downloadVideoMemeBtn');
  const exportVideoBtn = document.getElementById('exportVideoBtn');

  let videoPlaying = false;
  let videoInterval;

  videoUpload.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    videoElem.src = URL.createObjectURL(file);
    videoElem.style.display = 'block';
    videoCanvas.style.display = 'block';
    videoElem.load();
    videoElem.pause();
    playVideoBtn.disabled = false;
    pauseVideoBtn.disabled = true;
    downloadVideoMemeBtn.disabled = false;
    exportVideoBtn.disabled = false;
  };

  function drawVideoFrame() {
    videoCanvas.width = videoElem.videoWidth;
    videoCanvas.height = videoElem.videoHeight;
    videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
    videoCtx.drawImage(videoElem, 0, 0);
    videoCtx.font = '40px Impact, Arial Black';
    videoCtx.fillStyle = 'white';
    videoCtx.strokeStyle = 'black';
    videoCtx.lineWidth = 3;
    videoCtx.textAlign = 'center';
    if(videoTopText.value) {
      videoCtx.fillText(videoTopText.value.toUpperCase(), videoCanvas.width / 2, 50);
      videoCtx.strokeText(videoTopText.value.toUpperCase(), videoCanvas.width / 2, 50);
    }
    if(videoBottomText.value) {
      videoCtx.fillText(videoBottomText.value.toUpperCase(), videoCanvas.width / 2, videoCanvas.height - 30);
      videoCtx.strokeText(videoBottomText.value.toUpperCase(), videoCanvas.width / 2, videoCanvas.height - 30);
    }
  }

  playVideoBtn.onclick = () => {
    videoElem.play();
    videoPlaying = true;
    playVideoBtn.disabled = true;
    pauseVideoBtn.disabled = false;
    videoInterval = setInterval(drawVideoFrame, 33);
  };
  pauseVideoBtn.onclick = () => {
    videoElem.pause();
    videoPlaying = false;
    playVideoBtn.disabled = false;
    pauseVideoBtn.disabled = true;
    clearInterval(videoInterval);
  };
  downloadVideoMemeBtn.onclick = () => {
    drawVideoFrame();
    const link = document.createElement('a');
    link.download = 'video-meme-snapshot.png';
    link.href = videoCanvas.toDataURL('image/png');
    link.click();
  };
  exportVideoBtn.onclick = () => {
    if(!videoCanvas.width || !videoCanvas.height) return alert('Load a video first!');
    const stream = videoCanvas.captureStream(30);
    const recorder = new MediaRecorder(stream, {mimeType: 'video/webm'});
    const chunks = [];
    recorder.ondataavailable = e => chunks.push(e.data);
    recorder.onstop = () => {
      const blob = new Blob(chunks, {type: 'video/webm'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'video-meme.webm';
      a.click();
      URL.revokeObjectURL(url);
    };
    recorder.start();
    let duration = 0;
    const maxDuration = 5000; // 5 seconds
    const interval = setInterval(() => {
      drawVideoFrame();
      duration += 100;
      if (duration >= maxDuration) {
        clearInterval(interval);
        recorder.stop();
      }
    }, 100);
  };

  /* ==== BRAIN ROT MAKER ==== */
  const brainRotUpload = document.getElementById('brainRotUpload');
  const brainRotVideo = document.getElementById('brainRotVideo');
  const brainRotCanvas = document.getElementById('brainRotCanvas');
  const playBrainRotBtn = document.getElementById('playBrainRotBtn');
  const pauseBrainRotBtn = document.getElementById('pauseBrainRotBtn');
  const downloadBrainRotBtn = document.getElementById('downloadBrainRotBtn');
  const presetsButtons = document.querySelectorAll('.brainrot-presets button');

  let brainRotVideoPlaying = false;
  let brainRotCtx = brainRotCanvas.getContext('2d');
  let brainRotEffect = 'none';

  brainRotUpload.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    if(file.type.startsWith('video/')) {
      brainRotVideo.src = url;
      brainRotVideo.style.display = 'block';
      brainRotCanvas.style.display = 'none';
      playBrainRotBtn.disabled = false;
      pauseBrainRotBtn.disabled = true;
      downloadBrainRotBtn.disabled = true;
    } else if(file.type.startsWith('image/')) {
      brainRotVideo.style.display = 'none';
      brainRotCanvas.style.display = 'block';
      const img = new Image();
      img.onload = () => {
        brainRotCanvas.width = img.width;
        brainRotCanvas.height = img.height;
        brainRotCtx.drawImage(img, 0, 0);
        applyBrainRotEffect();
        downloadBrainRotBtn.disabled = false;
      };
      img.src = url;
    }
  };

  presetsButtons.forEach(btn => {
    btn.onclick = () => {
      brainRotEffect = btn.dataset.preset;
      applyBrainRotEffect();
    };
  });

  function applyBrainRotEffect() {
    if(brainRotVideo.style.display === 'block') return; // video handled separately
    const imageData = brainRotCtx.getImageData(0, 0, brainRotCanvas.width, brainRotCanvas.height);
    const data = imageData.data;

    if (brainRotEffect === 'none') {
      // reload original image for no effect, do nothing here for now
      return;
    }
    for(let i=0; i<data.length; i+=4) {
      let r=data[i], g=data[i+1], b=data[i+2];
      if(brainRotEffect === 'invert') {
        data[i] = 255-r;
        data[i+1] = 255-g;
        data[i+2] = 255-b;
      } else if(brainRotEffect === 'colorShift') {
        data[i] = b;
        data[i+1] = r;
        data[i+2] = g;
      } else if(brainRotEffect === 'noise') {
        const noise = (Math.random() - 0.5) * 50;
        data[i] = Math.min(255, Math.max(0, r + noise));
        data[i+1] = Math.min(255, Math.max(0, g + noise));
        data[i+2] = Math.min(255, Math.max(0, b + noise));
      } else if(brainRotEffect === 'pixelate') {
        // simple pixelate effect: skip for demo
      } else if(brainRotEffect === 'glitch') {
        // simple glitch effect: swap random pixels
        if(i + 16 < data.length) {
          const tempR = data[i];
          data[i] = data[i+16];
          data[i+16] = tempR;
        }
      }
    }
    brainRotCtx.putImageData(imageData, 0, 0);
  }

  playBrainRotBtn.onclick = () => {
    if (brainRotVideo.src) {
      brainRotVideo.play();
      brainRotVideoPlaying = true;
      playBrainRotBtn.disabled = true;
      pauseBrainRotBtn.disabled = false;
    }
  };
  pauseBrainRotBtn.onclick = () => {
    if (brainRotVideo.src) {
      brainRotVideo.pause();
      brainRotVideoPlaying = false;
      playBrainRotBtn.disabled = false;
      pauseBrainRotBtn.disabled = true;
    }
  };
  downloadBrainRotBtn.onclick = () => {
    if (!brainRotCanvas.width || !brainRotCanvas.height) return;
    const link = document.createElement('a');
    link.download = 'brainrot.png';
    link.href = brainRotCanvas.toDataURL('image/png');
    link.click();
  };
</script>

</body>
</html>
